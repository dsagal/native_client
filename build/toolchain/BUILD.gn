# Copyright (c) 2014 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

#
# Templates for untarring and prepparing the toolchain must not be in the
# same file as the toolchain declarations to prevent circular dependencies
# when referencing a toolchain.
#

#
# Source sets for the various crtX.o files which can be used by multiple
# nacl toolchains.
#
source_set("crt_x86_32") {
  sources = [
    "//native_client/src/untrusted/stubs/crti_x86_32.S",
    "//native_client/src/untrusted/stubs/crtn_x86_32.S",
  ]
}

source_set("crt_x86_64") {
  sources = [
    "//native_client/src/untrusted/stubs/crti_x86_64.S",
    "//native_client/src/untrusted/stubs/crtn_x86_64.S",
  ]
}

source_set("crt_arm") {
  sources = [
    "//native_client/src/untrusted/stubs/crti_arm.S",
    "//native_client/src/untrusted/stubs/crtn_arm.S",
  ]
}

if (current_toolchain == "//native_client/build/toolchain/nacl:toolchain_prep") {
  #
  # Toolchain Assembly
  #
  # Assembling the (P)NaCl toolchains is done with the default toolchain.  Any
  # pieces that need to be compile for a fully assembled toolchain are created
  # by default toolchain groups which depend on targets specifiying a raw
  # toolchain such as libnacl.a or crtX.S.
  #
  # Toolchain assembly happens through the template "prep_toolchain" which
  # in turn invokes the following three steps:
  # 1- toolchain_untar
  # 2- toolchain_copies (at this point the raw toolchain is ready)
  # 3- toolchain_build (which generates the CRT and libnacl files)
  #

  #
  # Untar the toolchain and generate the untar'd stamp which is really a copy
  # of the json describing the file.  This used the default toolchain to avoid
  # circular dependencies.
  #
  template("toolchain_untar") {
    package = invoker.package
    action(target_name) {
      sources = [
        "//native_client/build/package_version/package_version.py",
        "//native_client/toolchain/.tars/${build_os}_x86/${package}.json",
      ]
      outputs = [ "${root_build_dir}/toolchain/${build_os}_x86/${package}/${package}.json" ]
      script = "//native_client/build/package_version/package_version.py"
      args = [
        "--quiet",
        "--packages",
        package,
        "--tar-dir", rebase_path("//native_client/toolchain/.tars", root_build_dir),
        "--dest-dir",rebase_path("${root_build_dir}/toolchain", root_build_dir),
        "extract"
      ]
    }
  }

  #
  # Copy appropriate nacl headers and empty crt1.o
  #
  template("toolchain_copies") {
    package = invoker.package
    package_libc = invoker.package_libc
    package_arch = invoker.package_arch
    toolchain_dir = invoker.toolchain_dir

    if (package_arch != "arm") {
      install_dir = "${toolchain_dir}/x86_64-nacl"
    } else {
      install_dir = "${toolchain_dir}/arm-nacl"
    }

    #
    # Copy headers into <TC>/<ARCH>/include
    #
    copy("${target_name}_root_headers") {
      sources = [
        "//native_client/src/untrusted/irt/irt.h",
        "//native_client/src/untrusted/irt/irt_dev.h",
      ]

      if (package_libc == "newlib") {
        sources += [
          "//native_client/src/untrusted/pthread/pthread.h",
          "//native_client/src/untrusted/pthread/semaphore.h",
        ]
      }
      outputs = [ "${install_dir}/include/{{source_file_part}}" ]
      deps = [
        "//native_client/build/toolchain:${package}_untar"
      ]
    }

    #
    # Copy headers into <TC>/<ARCH>/include/nacl
    #
    copy("${target_name}_nacl_headers") {
      sources = [
        "//native_client/src/include/nacl/nacl_exception.h",
        "//native_client/src/include/nacl/nacl_minidump.h",
        "//native_client/src/untrusted/nacl/nacl_dyncode.h",
        "//native_client/src/untrusted/nacl/nacl_startup.h",
        "//native_client/src/untrusted/nacl/nacl_thread.h",
        "//native_client/src/untrusted/valgrind/dynamic_annotations.h",
      ]
      outputs = [ "${install_dir}/include/nacl/{{source_file_part}}" ]
      deps = [
        "//native_client/build/toolchain:${package}_untar"
      ]
    }

    if (package_libc == "newlib") {
      #
      # Copy empty CRT files to <TC>/<ARCH>/lib
      #
      copy("${target_name}_crt1") {
        sources = [  "//native_client/src/untrusted/stubs/crt1.x" ]
        outputs = [ "${install_dir}/lib/crt1.o" ]
        deps = [
          "//native_client/build/toolchain:${package}_untar"
        ]
      }
      if (package_arch == "x86") {
        copy("${target_name}_crt1_32") {
          sources = [  "//native_client/src/untrusted/stubs/crt1.x" ]
          outputs = [ "${install_dir}/lib32/crt1.o" ]
          deps = [
            "//native_client/build/toolchain:${package}_untar"
          ]
        }
      }
    }

    group(target_name) {
      if (defined(datadeps) == false) {
        datadeps = []
      }

      datadeps += [
        # Header copy targets
        ":${target_name}_root_headers",
        ":${target_name}_nacl_headers",
      ]

      if (package_libc == "newlib") {
        datadeps += [
          ":${target_name}_crt1"
        ]
        if (package_arch == "x86") {
          datadeps += [
            ":${target_name}_crt1_32"
          ]
        }
      }
    }
  }

  #
  # Invoke toolchain specific dependencies on the CRT files and libnacl.a then
  # copy them to the toolchain directory.
  #
  template("toolchain_build") {
    package_libc = invoker.package_libc
    if (package_libc == "newlib") {
      toolchain_prefix = invoker.toolchain_prefix
      package_arch = invoker.package_arch
      toolchain_dir = invoker.toolchain_dir

      raw_toolchain = "raw_${toolchain_prefix}_${package_arch}"

      if (package_arch != "arm") {
        install_dir = "${toolchain_dir}/x86_64-nacl"
      } else {
        install_dir = "${toolchain_dir}/arm-nacl"
      }
      obj_dir = "${root_build_dir}/${raw_toolchain}/obj"

      #
      # Copy crti, crtn, and crt1 into <TC>/<ARCH>/lib
      #
      if (package_arch == "arm") {
        crt_path = "${obj_dir}/native_client/src/untrusted/stubs"
        copy("${target_name}_crti_arm") {
          sources = [  "${crt_path}/crt_arm.crti_arm.o" ]
          outputs = [ "${install_dir}/lib/crti.o" ]
          deps = [
            ":crt_arm(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_arm)"
          ]
        }
        copy("${target_name}_crtn_arm") {
          sources = [  "${crt_path}/crt_arm.crtn_arm.o" ]
          outputs = [ "${install_dir}/lib/crtn.o" ]
          deps = [
            ":crt_arm(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_arm)"
          ]
        }
        copy("${target_name}_libnacl_arm") {
          sources = [ "${obj_dir}/native_client/src/untrusted/nacl/libnacl.a" ]
          outputs = [ "${install_dir}/lib/libnacl.a" ]
          deps = [
            "//native_client/src/untrusted/nacl:nacl(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_arm)",
          ]
        }
      } else {
        crt_path = "${obj_dir}/native_client/src/untrusted/stubs"
        copy("${target_name}_crti_x86_32") {
          sources = [  "${crt_path}/crt_x86_32.crti_x86_32.o" ]
          outputs = [ "${install_dir}/lib32/crti.o" ]
          deps = [
            ":crt_x86_32(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x86)",
          ]
        }
        copy("${target_name}_crtn_x86_32") {
          sources = [  "${crt_path}/crt_x86_32.crtn_x86_32.o" ]
          outputs = [ "${install_dir}/lib32/crtn.o" ]
          deps = [
            ":crt_x86_32(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x86)",
          ]
        }
        copy("${target_name}_libnacl_x86_32") {
          sources = [ "${obj_dir}/native_client/src/untrusted/nacl/libnacl.a" ]
          outputs = [ "${install_dir}/lib32/libnacl.a" ]
          deps = [
            "//native_client/src/untrusted/nacl:nacl(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x86)",
          ]
        }
        copy("${target_name}_libpthread_x86_32") {
          sources = [ "${obj_dir}/native_client/src/untrusted/pthread/libpthread.a" ]
          outputs = [ "${install_dir}/lib32/libpthread.a" ]
          deps = [
            "//native_client/src/untrusted/pthread:pthread(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x86)",
          ]
        }

        obj_dir = "${root_build_dir}/raw_${toolchain_prefix}_x64/obj"
        crt_path = "${obj_dir}/native_client/src/untrusted/stubs"
        copy("${target_name}_crti_x86_64") {
          sources = [  "${crt_path}/crt_x86_64.crti_x86_64.o" ]
          outputs = [ "${install_dir}/lib/crti.o" ]
          deps = [
            ":crt_x86_64(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x64)",
          ]
        }
        copy("${target_name}_crtn_x86_64") {
          sources = [  "${crt_path}/crt_x86_64.crtn_x86_64.o" ]
          outputs = [ "${install_dir}/lib/crtn.o" ]
          deps = [
            ":crt_x86_64(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x64)",
          ]
        }
        copy("${target_name}_libnacl_x86_64") {
          sources = [ "${obj_dir}/native_client/src/untrusted/nacl/libnacl.a" ]
          outputs = [ "${install_dir}/lib/libnacl.a" ]
          deps = [
            "//native_client/src/untrusted/nacl:nacl(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x64)",
          ]
        }
        copy("${target_name}_libpthread_x86_64") {
          sources = [ "${obj_dir}/native_client/src/untrusted/pthread/libpthread.a" ]
          outputs = [ "${install_dir}/lib/libpthread.a" ]
          deps = [
            "//native_client/src/untrusted/pthread:pthread(//native_client/build/toolchain/nacl:raw_${toolchain_prefix}_x64)",
          ]
        }
      }
    }

    group(target_name) {
      if (package_libc == "newlib") {
        if (package_arch == "arm") {
          datadeps = [
            ":${target_name}_crti_arm",
            ":${target_name}_crtn_arm",
            ":${target_name}_libnacl_arm",
            ":${target_name}_libpthread_arm",
          ]
        } else {
          datadeps = [
            ":${target_name}_crti_x86_32",
            ":${target_name}_crtn_x86_32",
            ":${target_name}_libnacl_x86_32",
            ":${target_name}_libpthread_x86_32",
            ":${target_name}_crtn_x86_64",
            ":${target_name}_crti_x86_64",
            ":${target_name}_libnacl_x86_64",
            ":${target_name}_libpthread_x86_64",
          ]
        }
      }
    }
  }

  #
  # Untarring and prepping the toolchains happens with the default toolchain
  # to pull in COPY and TOUCH tools, and to avoid a cyclic dependency.  All
  # normal NaCl targets should depend on :prep_<arch>_<libc>(<host_toolchain>)
  #
  template("prep_toolchain") {
    package = invoker.package
    package_arch = invoker.package_arch
    package_libc = invoker.package_libc

    toolchain_untar("${package}_untar") {}
    toolchain_copies("${package}_copies") {
      toolchain_dir = "${root_build_dir}/toolchain/${build_os}_x86/${package}"
    }

    if (package_libc == "newlib") {
      toolchain_prefix = invoker.toolchain_prefix
      toolchain_build("${package}_build") {
        toolchain_dir = "${root_build_dir}/toolchain/${build_os}_x86/${package}"
      }
    }

    group(target_name) {
      datadeps = [
        ":${package}_untar",
        ":${package}_copies",
      ]
      if (package_libc == "newlib") {
        datadeps += [
          ":${package}_build",
        ]
      }
    }
  }

  prep_toolchain("prep_nacl_arm_newlib") {
    package = "nacl_arm_newlib"
    toolchain_prefix = "newlib"
    package_arch = "arm"
    package_libc = "newlib"
  }

  prep_toolchain("prep_nacl_x86_newlib") {
    package = "nacl_x86_newlib"
    toolchain_prefix = "newlib"
    package_arch = "x86"
    package_libc = "newlib"
  }

  prep_toolchain("prep_nacl_x86_glibc") {
    package = "nacl_x86_glibc"
    # GN is pretty agressive when warning about unused variables.
    # toolchain_prefix is currently not used, in a dynamic sense, so it is
    # commented out.
    #toolchain_prefix = "glibc"
    package_arch = "x86"
    package_libc = "glibc"
  }
}